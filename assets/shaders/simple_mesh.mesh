#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

struct Meshlet
{
  uint vertexOffset;
  uint triangleOffset;
  uint vertexCount;
  uint triangleCount;

  float center[3];
  float radius;

  float cone_axis[3];
  float cone_cutoff;
};

layout(buffer_reference, scalar) readonly buffer MeshletBuffer
{
  Meshlet meshlets[];
};

layout(buffer_reference, scalar) readonly buffer MeshletVerticesBuffer
{
  uint vertexIndices[];
};

layout(buffer_reference, scalar) readonly buffer MeshletTrianglesBuffer
{
  uint8_t triangleIndices[];
};

struct Vertex
{
  vec3 position;
  vec3 color;
  vec3 normal;
  vec2 uv;
  int  materialId;
};

layout(buffer_reference, scalar) readonly buffer VertexBuffer
{
  Vertex vertices[];
};

layout(push_constant) uniform Push
{
  mat4  modelMatrix;
  mat4  normalMatrix;
  uint  meshId;

  uint64_t meshletBufferAddress;
  uint64_t meshletVerticesAddress;
  uint64_t meshletTrianglesAddress;
  uint64_t vertexBufferAddress;
  uint     meshletOffset;
  uint     meshletCount;
  vec2     screenSize;
}
push;

layout(set = 0, binding = 0) uniform GlobalUbo
{
  mat4 projection;
  mat4 view;
}
ubo;

layout(location = 0) out vec3 outColor[];
layout(location = 1) out vec3 outWorldPos[];
layout(location = 2) out vec3 outNormal[];
layout(location = 3) out vec2 outUV[];

struct TaskPayload
{
  uint meshletIndices[32];
};

taskPayloadSharedEXT TaskPayload payload;

void main()
{
  uint meshletId = payload.meshletIndices[gl_WorkGroupID.x];

  MeshletBuffer meshletBuffer = MeshletBuffer(push.meshletBufferAddress);
  Meshlet       meshlet       = meshletBuffer.meshlets[meshletId];

  SetMeshOutputsEXT(meshlet.vertexCount, meshlet.triangleCount);

  MeshletVerticesBuffer meshletVertices = MeshletVerticesBuffer(push.meshletVerticesAddress);
  VertexBuffer          vertexBuffer    = VertexBuffer(push.vertexBufferAddress);

  // Calculate normal matrix
  mat3 normalMatrix = mat3(push.normalMatrix);

  for (uint i = gl_LocalInvocationIndex; i < meshlet.vertexCount; i += 32)
  {
    uint   vertexIndex = meshletVertices.vertexIndices[meshlet.vertexOffset + i];
    Vertex v           = vertexBuffer.vertices[vertexIndex];

    gl_MeshVerticesEXT[i].gl_Position = ubo.projection * ubo.view * push.modelMatrix * vec4(v.position, 1.0);

    outColor[i]    = v.color;
    outWorldPos[i] = (push.modelMatrix * vec4(v.position, 1.0)).xyz;
    outNormal[i]   = normalize(normalMatrix * v.normal);
    outUV[i]       = v.uv;
  }

  MeshletTrianglesBuffer meshletTriangles = MeshletTrianglesBuffer(push.meshletTrianglesAddress);

  for (uint i = gl_LocalInvocationIndex; i < meshlet.triangleCount; i += 32)
  {
    uint    baseTriIdx = meshlet.triangleOffset + (i * 3);
    uint8_t idx0       = meshletTriangles.triangleIndices[baseTriIdx + 0];
    uint8_t idx1       = meshletTriangles.triangleIndices[baseTriIdx + 1];
    uint8_t idx2       = meshletTriangles.triangleIndices[baseTriIdx + 2];

    gl_PrimitiveTriangleIndicesEXT[i] = uvec3(idx0, idx1, idx2);
  }
}
