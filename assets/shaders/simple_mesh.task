#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Meshlet
{
  uint vertexOffset;
  uint triangleOffset;
  uint vertexCount;
  uint triangleCount;

  float center[3];
  float radius;

  float cone_axis[3];
  float cone_cutoff;
};

layout(buffer_reference, scalar) readonly buffer MeshletBuffer
{
  Meshlet meshlets[];
};

layout(push_constant) uniform Push
{
  mat4  modelMatrix;
  mat4  normalMatrix;
  vec3  albedo;
  float metallic;
  float roughness;
  float ao;
  float isSelected;
  float clearcoat;
  float clearcoatRoughness;
  float anisotropic;
  float anisotropicRotation;
  uint  textureFlags;
  float uvScale;
  uint  albedoIndex;
  uint  normalIndex;
  uint  metallicIndex;
  uint  roughnessIndex;
  uint  aoIndex;
  uint  meshId;

  uint64_t meshletBufferAddress;
  uint64_t meshletVerticesAddress;
  uint64_t meshletTrianglesAddress;
  uint64_t vertexBufferAddress;
  uint     meshletOffset;
  uint     meshletCount;
  vec2     screenSize;
}
push;

layout(set = 0, binding = 0) uniform GlobalUbo
{
  mat4 projection;
  mat4 view;
  vec4 ambientLightColor;
  vec4 cameraPosition;
}
ubo;

// Task payload to pass to mesh shader
struct TaskPayload
{
  uint meshletIndices[32];
};

taskPayloadSharedEXT TaskPayload payload;

bool isVisible(Meshlet meshlet, mat4 model, vec3 cameraPos)
{
  // 1. Transform center to world space
  vec3  center      = vec3(meshlet.center[0], meshlet.center[1], meshlet.center[2]);
  vec3  worldCenter = (model * vec4(center, 1.0)).xyz;
  float radius      = meshlet.radius * max(length(model[0]), max(length(model[1]), length(model[2]))); // Approximate scale

  // 2. Frustum Culling
  mat4 vp   = ubo.projection * ubo.view;
  mat4 vpT  = transpose(vp);
  vec4 row0 = vpT[0];
  vec4 row1 = vpT[1];
  vec4 row2 = vpT[2];
  vec4 row3 = vpT[3];

  vec4 planes[6];
  planes[0] = row3 + row0; // Left
  planes[1] = row3 - row0; // Right
  planes[2] = row3 + row1; // Bottom
  planes[3] = row3 - row1; // Top
  planes[4] = row2;        // Near
  planes[5] = row3 - row2; // Far

  for (int i = 0; i < 6; i++)
  {
    if (dot(planes[i], vec4(worldCenter, 1.0)) < -radius)
    {
      return false;
    }
  }

  // 3. Cone Culling (Backface)
  vec3 coneAxis = vec3(meshlet.cone_axis[0], meshlet.cone_axis[1], meshlet.cone_axis[2]);
  // Transform cone axis to world space (assuming uniform scale or close to it)
  vec3 worldConeAxis = normalize(mat3(model) * coneAxis);
  vec3 viewDir       = normalize(cameraPos - worldCenter);

  // If the cone points away from the camera more than the cutoff angle allows
  if (dot(worldConeAxis, viewDir) >= meshlet.cone_cutoff)
  {
    return true; // Visible
  }

  // 4. Screen Size Culling (LOD)
  vec4  viewCenter = ubo.view * vec4(worldCenter, 1.0);
  float dist       = -viewCenter.z;

  if (dist > 0.01)
  {
    float p11             = ubo.projection[1][1];
    float projectedRadius = (radius * p11) / dist;
    float pixelRadius     = projectedRadius * push.screenSize.y * 0.5;

    if (pixelRadius < 1.0)
    {
      return false;
    }
  }

  return true;
}

void main()
{
  uint meshletIndex = gl_GlobalInvocationID.x;
  if (meshletIndex >= push.meshletCount)
  {
    return;
  }

  uint meshletId = push.meshletOffset + meshletIndex;

  // We don't know the total meshlet count here easily without passing it.
  // But we can assume the dispatch size is correct.
  // However, we should check if meshletId is valid if we passed a total count.
  // For now, assume dispatch is aligned.

  MeshletBuffer meshletBuffer = MeshletBuffer(push.meshletBufferAddress);
  Meshlet       meshlet       = meshletBuffer.meshlets[meshletId];

  bool visible = isVisible(meshlet, push.modelMatrix, ubo.cameraPosition.xyz);

  // Subgroup voting
  uvec4 vote         = subgroupBallot(visible);
  uint  visibleCount = subgroupBallotBitCount(vote);
  uint  indexOffset  = subgroupBallotExclusiveBitCount(vote);

  if (visible)
  {
    payload.meshletIndices[indexOffset] = meshletId;
  }

  if (gl_LocalInvocationIndex == 0)
  {
    EmitMeshTasksEXT(visibleCount, 1, 1);
  }
}
